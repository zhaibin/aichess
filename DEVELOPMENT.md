# 开发文档

## 项目架构

\`\`\`
┌─────────────────┐
│   前端界面      │
│  (HTML/CSS/JS)  │
└────────┬────────┘
         │ HTTP API
         ▼
┌─────────────────┐
│ Cloudflare      │
│ Workers         │
│ (index.ts)      │
└────┬─────┬──────┘
     │     │
     │     └──────────────┐
     │                    │
     ▼                    ▼
┌─────────────┐   ┌──────────────┐
│  Durable    │   │  AI Queue    │
│  Objects    │   │  (AI vs AI)  │
│(GameState)  │   └──────────────┘
└─────────────┘            │
                           ▼
                   ┌──────────────┐
                   │ Workers AI   │
                   │ (5个模型)    │
                   └──────────────┘
\`\`\`

## 核心模块

### 1. index.ts - Workers主入口

负责：
- HTTP请求路由
- 静态HTML服务
- API端点处理
- 队列消息处理

主要端点：
- `GET /` - 返回HTML界面
- `POST /api/create-game` - 创建游戏
- `POST /api/make-move` - 执行移动
- `GET /api/game-state?gameId=xxx` - 获取游戏状态
- `GET /api/ai-models` - 获取AI模型列表

### 2. game-state.ts - Durable Objects

负责：
- 游戏状态持久化
- 移动验证
- 时间管理
- 胜负判定

每个游戏有独立的Durable Object实例。

### 3. chess-utils.ts - 国际象棋工具

基于chess.js库，提供：
- 移动合法性验证
- FEN格式处理
- 游戏状态检查（将军、将死、和棋）
- UCI格式转换

### 4. ai-player.ts - AI棋手

负责：
- 生成AI提示词
- 调用Workers AI模型
- 解析AI响应
- 错误重试机制
- 备用随机移动

### 5. i18n.ts - 多语言支持

包含11种语言的翻译字典。

### 6. types.ts - TypeScript类型定义

定义所有接口和类型。

## 数据流程

### 创建游戏

\`\`\`
用户 -> POST /api/create-game
     -> Workers创建Durable Object
     -> 初始化GameState
     -> 如果是AI vs AI，发送队列消息
     -> 返回游戏ID和初始状态
\`\`\`

### 人类移动

\`\`\`
用户 -> POST /api/make-move
     -> Durable Object验证移动
     -> 更新游戏状态
     -> 如果对手是AI，发送队列消息
     -> 返回新状态
\`\`\`

### AI移动（通过队列）

\`\`\`
队列消息 -> Workers queue handler
         -> 获取游戏状态
         -> 调用Workers AI
         -> 解析AI响应
         -> Durable Object执行移动
         -> 如果对手也是AI，发送下一个队列消息
\`\`\`

## AI提示词设计

### 系统提示词

明确AI的角色和规则：
- 你是专业棋手
- 遵守FIDE规则
- 时间限制
- 输入/输出格式

### 用户提示词

包含当前游戏状态：
- FEN格式的棋盘
- 移动历史（SAN格式）
- 双方剩余时间
- 上一步移动

### AI响应格式

要求AI返回JSON：
\`\`\`json
{
  "move": "e2e4"  // UCI格式
}
\`\`\`

或提和：
\`\`\`json
{
  "draw": true
}
\`\`\`

## 时间控制实现

每次移动时：
1. 记录当前时间
2. 计算距上次移动的时间差
3. 从当前玩家的剩余时间中扣除
4. 检查是否超时

前端每秒轮询更新计时器显示。

## 移动验证流程

1. 前端：点击棋子 -> 显示可能的移动
2. 前端：点击目标位置 -> 发送API请求
3. 后端：使用chess.js验证移动合法性
4. 后端：检查是否导致游戏结束
5. 后端：更新时间和状态
6. 后端：返回新状态
7. 前端：更新界面

## 队列使用原因

AI vs AI对战可能导致：
- 长时间运行（超过Workers CPU限制）
- 递归调用问题

使用队列解决：
- 每次AI移动作为独立任务
- 2秒延迟模拟思考时间
- 自动重试机制
- 死信队列处理失败

## 响应式设计

### PC端（宽度 >= 1024px）
\`\`\`
┌────────────┬─────────┐
│            │ 玩家信息│
│   棋盘     ├─────────┤
│            │行棋历史 │
└────────────┴─────────┘
\`\`\`

### 移动端（宽度 < 1024px）
\`\`\`
┌──────────────┐
│  玩家信息    │
├──────────────┤
│    棋盘      │
├──────────────┤
│  行棋历史    │
└──────────────┘
\`\`\`

## 测试建议

### 单元测试

测试chess-utils.ts：
- 移动验证
- FEN解析
- 游戏状态检查

### 集成测试

测试完整游戏流程：
- 创建游戏
- 执行移动
- 时间管理
- AI对战

### 本地测试

\`\`\`bash
npm run dev
\`\`\`

### 远程测试

\`\`\`bash
npm run deploy
npm run tail  # 查看日志
\`\`\`

## 调试技巧

### 1. 查看Workers日志

\`\`\`bash
npx wrangler tail
\`\`\`

### 2. 本地开发模式

\`\`\`bash
npx wrangler dev --local
\`\`\`

### 3. 添加日志

在代码中添加：
\`\`\`typescript
console.log('Debug info:', data);
\`\`\`

### 4. 检查Durable Objects状态

通过API获取游戏状态：
\`\`\`bash
curl https://aichess.win/api/game-state?gameId=xxx
\`\`\`

## 性能优化

1. **缓存策略**：静态资源使用CDN缓存
2. **代码分割**：HTML内嵌，减少请求
3. **Durable Objects**：游戏状态就近存储
4. **队列批处理**：AI移动异步处理
5. **前端优化**：虚拟DOM最小化重绘

## 扩展建议

### 短期
- [ ] 添加认输功能API
- [ ] 实现提和/接受和棋
- [ ] 添加游戏历史列表
- [ ] 实现回放功能

### 中期
- [ ] 用户认证系统
- [ ] ELO评分系统
- [ ] 游戏分析功能
- [ ] 开局库集成

### 长期
- [ ] WebSocket实时对战
- [ ] 锦标赛系统
- [ ] 社交功能
- [ ] 移动应用

## 代码规范

- TypeScript严格模式
- ESLint配置
- Prettier格式化
- 函数注释（JSDoc）
- 错误处理必须完善

## 安全考虑

1. **输入验证**：所有API输入验证
2. **CORS配置**：适当的CORS策略
3. **速率限制**：防止滥用（可选）
4. **AI注入**：AI响应JSON严格解析
5. **游戏锁定**：防止并发修改

